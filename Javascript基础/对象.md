#### 一些常用方法

for in 循环输出key和每一项值。

```javascript
for(var key in obj){
    console.log(key,obj[key])
}
//直接获得对象的每个key
Object.keys(obj)
```
###Object.defineProperty()方法

```javascript
var book = { 
 _year: 2004, 
 edition: 1 
}; 
Object.defineProperty(book, "year", { 
 get: function(){ 
 return this._year; 
 }, 
 set: function(newValue){ 
 if (newValue > 2004) { 
 this._year = newValue; 
 this.edition += newValue - 2004; 
 } 
 } 
}); 
```
#### 原型与原型链

所有引用类型（函数，数组，对象）都拥有__proto__属性（隐式原型）
所有函数拥有prototype属性（显式原型）（仅限函数）

函数(f)存着一个地址指向堆中，有一个显式原型对象prototype，原型对象中有一个属性constructor, 它指向函数对象。
实例(o)也存着一个地址指向堆中，是一个由函数构造出来的对象，有一个隐式原型对象__proto__，和prototype指向的是同一个对象。 这个对象有一个隐式原型对象__proto__指向Object的实例对象，里面含有toString，vuleOf等方法，和一个__proto__值为null
即有下面的等式关系

```javascript
f.prototype == o.__proto__;
f.prototype.__proto__ == o.__proto__.__proto__ == Object.prototype;
o.__proto__.__proto__.__proto__==Object.prototype.__proto__==null
```
函数的显示原型指向的对象默认是空Object实例对象(但Object不满足)
```javascript
Fn.prototype instanceof Object // true
Object.prototype instanceof Object// false
Function.prototype instanceof Object // true
```
所有函数都是Function的实例(包含Function)
Function是通过new自己产生的实例

```javascript
Function.__proto__===Function.prototype
```
 函数本身也是一个对象，所有(构造)函数的__proto__属性都指向Function构造函数的prototype，Function构造函数的__proto__属性也指向Function构造函数的prototype
Object也是构造函数，同上。

 #### instanceof是如何判断的?
 如: obj instanceof Object
  在实例obj的原型链上寻找，如果和构造函数Object的显式原型相连， 返回true, 否则返回false。

#### 原型链继承

```javascript
function Father(){
  this.fathername = 'father';
};
Father.prototype.getFathername = function(){
  return this.fathername;
};
function Son(){
  this.Sonname = 'son';
}
Son.prototype = new Father();
Son.prototype.getSonname = function(){
  return this.Sonname;
}
var son = new Son;
console.log(son.getFathername() )
```
  原型链+借用构造函数的组合继承
1. 利用原型链实现对父类型对象的方法继承
2. 利用call()借用父类型构建函数初始化相同属性
```javascript
  function Person(name, age) {
    this.name = name
    this.age = age
  }
  Person.prototype.setName = function (name) {
    this.name = name
  }
  function Student(name, age, price) {
    Person.call(this, name, age) //得到父类型的属性
    this.price = price
  }
  Student.prototype = new Person()  //得到父类型的方法
  Student.prototype.constructor = Student
  Student.prototype.setPrice = function (price) {
    this.price = price
  }
  var s = new Student('Tom', 12, 10000)
  s.setPrice(11000)
  s.setName('Bob')
  console.log(s)
```