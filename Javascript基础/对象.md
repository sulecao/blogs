#### 一些常用方法

for in 循环输出key和每一项值。对象的属性没有顺序，所以循环输出的属性顺序是不可预测的。如果对象的变量值有null或undefined，会不再执行循环。
for(var prop in window){ console.log(prop)}

```javascript
for(var key in obj){
    console.log(key,obj[key])
}
//直接获得对象的每个key
Object.keys(obj)
```
##### Object.defineProperty()方法

```javascript
var book = { 
 _year: 2004, 
 edition: 1 
}; 
Object.defineProperty(book, "year", { 
 get: function(){ 
 return this._year; 
 }, 
 set: function(newValue){ 
 if (newValue > 2004) { 
 this._year = newValue; 
 this.edition += newValue - 2004; 
 } 
 } 
}); 
```
#### 原型与原型链

所有引用类型（函数，数组，对象）都拥有__proto__属性（隐式原型）
所有函数拥有prototype属性（显式原型）（仅限函数）

函数(f)存着一个地址指向堆中，有一个显式原型对象prototype，原型对象中有一个属性constructor, 它指向函数对象。
实例(o)也存着一个地址指向堆中，是一个由函数构造出来的对象，有一个隐式原型对象__proto__，和prototype指向的是同一个对象。 这个对象有一个隐式原型对象__proto__指向Object的实例对象，里面含有toString，vuleOf等方法，和一个__proto__值为null
即有下面的等式关系

```javascript
f.prototype == o.__proto__;
f.prototype.__proto__ == o.__proto__.__proto__ == Object.prototype;
o.__proto__.__proto__.__proto__==Object.prototype.__proto__==null
```
函数的显示原型指向的对象默认是空Object实例对象(但Object不满足)
```javascript
Fn.prototype instanceof Object // true
Object.prototype instanceof Object// false
Function.prototype instanceof Object // true
```
所有函数都是Function的实例(包含Function)
Function是通过new自己产生的实例

```javascript
Function.__proto__===Function.prototype
```
 函数本身也是一个对象，所有(构造)函数的__proto__属性都指向Function构造函数的prototype，Function构造函数的__proto__属性也指向Function构造函数的prototype
Object也是构造函数，同上。

 #### instanceof是如何判断的?
 如: obj instanceof Object
  在实例obj的原型链上寻找，如果和构造函数Object的显式原型相连， 返回true, 否则返回false。

#### 原型链继承

```javascript
function Father(){
  this.fathername = 'father';
};
Father.prototype.getFathername = function(){
  return this.fathername;
};
function Son(){
  this.Sonname = 'son';
}
Son.prototype = new Father();
Son.prototype.getSonname = function(){
  return this.Sonname;
}
var son = new Son;
console.log(son.getFathername() )
```
  原型链+借用构造函数的组合继承
1. 利用原型链实现对父类型对象的方法继承
2. 利用call()借用父类型构建函数初始化相同属性
```javascript
  function Person(name, age) {
    this.name = name
    this.age = age
  }
  Person.prototype.setName = function (name) {
    this.name = name
  }
  function Student(name, age, price) {
    Person.call(this, name, age) //得到父类型的属性
    this.price = price
  }
  Student.prototype = new Person()  //得到父类型的方法
  Student.prototype.constructor = Student
  Student.prototype.setPrice = function (price) {
    this.price = price
  }
  var s = new Student('Tom', 12, 10000)
  s.setPrice(11000)
  s.setName('Bob')
  console.log(s)
```

new关键字的过程

1. 新生成一个空对象
2. 将空对象链接到原型中
3. 绑定this
4. 返回新对象

#工厂模式
缺点：无法知道对象是什么类型。

```
function createPerson(name, age, job){ 
 var o = new Object(); 
 o.name = name; 
 o.age = age; 
 o.job = job; 
 o.sayName = function(){ 
 alert(this.name); 
 }; 
 return o; 
} 
var person1 = createPerson("Nicholas", 29, "Software Engineer"); 
var person2 = createPerson("Greg", 27, "Doctor"); 
```

#构造函数模式

使用 new 来调用函数，或发生构造函数调用时，会自动执行下面的操作。

1. 创建一个新对象。
2. 将构造函数的作用域赋给新对象，this就指向这个新对象。如果不使用new，this指向window。
3. 执行代码，为对象添加属性
4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象

```
function Person(name, age, job){ 
 this.name = name; 
 this.age = age; 
 this.job = job; 
 this.sayName = function(){ 
 alert(this.name); 
 }; 
} 
var person1 = new Person("Nicholas", 29, "Software Engineer"); 
var person2 = new Person("Greg", 27, "Doctor"); 
//都是Person的实例
//person1 instanceof Person的值为true
//缺点是创建了很多完成同样任务的函数（同名但实际不是一个）。
```

#原型模式

```
function Person(){ 
} 
Person.prototype.name = "Nicholas"; 
Person.prototype.age = 29; 
Person.prototype.job = "Software Engineer"; 
Person.prototype.sayName = function(){ 
 alert(this.name); 
}; 
var person1 = new Person(); 
person1.sayName(); //"Nicholas" 
```

#混合模式

```
function Person(name, age, job){ 
 this.name = name; 
 this.age = age; 
 this.job = job; 
 this.friends = ["Shelby", "Court"]; 
} 
Person.prototype = { 
 constructor : Person, 
 sayName : function(){ 
 alert(this.name); 
 } 
} 
var person1 = new Person("Nicholas", 29, "Software Engineer"); 
var person2 = new Person("Greg", 27, "Doctor"); 
//尽管可以随时为原型添加属性和方法，
//把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系
动态原型模式
function Person(name, age, job){ 
 //属性
 this.name = name; 
 this.age = age; 
 this.job = job;
//方法
 if (typeof this.sayName != "function"){ 
 Person.prototype.sayName = function(){ 
 alert(this.name); 
 }; 
 } 
} 
```

#寄生构造函数模式 
用于自定义一些方法

```
function Person(name, age, job){ 
 var o = new Object(); 
 o.name = name; 
 o.age = age; 
 o.job = job; 
 o.sayName = function(){ 
 alert(this.name); 
 }; 
 return o; 
} 
创建一个带toPipedString 方法的数组
function SpecialArray(){ 
 //创建数组
 var values = new Array(); 
 //添加值
 values.push.apply(values, arguments); 
 //添加方法
 values.toPipedString = function(){ 
 return this.join("|"); 
 }; 
 //返回数组
 return values; 
} 
var colors = new SpecialArray("red", "blue", "green"); 
alert(colors.toPipedString()); //"red|blue|green"
```

#稳妥构造函数模式
 安全性需要时使用

```
function Person(name, age, job){ 
 //创建要返回的对象
 var o = new Object();
//可以在这里定义私有变量和函数
 //添加方法
 o.sayName = function(){ 
 alert(name); 
 }; 
 //返回对象
 return o; 
} 
//注意，在以这种模式创建的对象中，除了使用 sayName()方法之外，没有其他办法访问 name 的值。
//可以像下面使用稳妥的 Person 构造函数。
var friend = Person("Nicholas", 29, "Software Engineer"); 
friend.sayName(); //"Nicholas"
```