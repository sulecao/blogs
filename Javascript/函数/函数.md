

#### 函数

函数实际上是对象，每个函数都是Function的实例。函数名仅仅存着指向函数的指针，所以一个函数可以有多个名字。所以javascript函数没有重载，后面的会覆盖前面的。

#### 函数的返回值

如果return后面没跟内容，或者没有写return ，返回undefined；

#### rguments.callee

是一个指针，指向拥有这个 arguments 对象的函数（即正在执行的函数），这样factorial赋值给新的函数，factorial被修改了，使用新的函数也不会出错。

```js
function factorial(num){ 
 if (num <=1) { 
 return 1; 
 } else { 
 return num * arguments.callee(num-1) 
 } 
} 
```
#### this

this代表调用函数的当前对象，在定义函数时, this还没有确定, 只有在执行时才动态确定(绑定)的，本质上任何函数在执行时都是通过某个对象调用的,如果没有直接指定就是window。

##### this的值的几种情况

test()  直接使用方法  this的值为window
obj.test()  obj使用方法  this的值为obj
new test()  返回的实例对象
test.call(obj) 用call，apply，bind,改变函数的this，返回一个新的函数，不调用函数。

指定this对象，this为指定的obj可以分两波参数传递

绑定事件函数的this，

定时器里的this

定时器

```javascript
 setTimeout(function() {
       console.log(this)
   }, 100); //window
```

apply()方法
function.apply(thisObj,[argArray])
call()方法
function.call(thisObj, arg1, arg2, ...);

##### 几个注意点

```js
//如果使用严格模式（strict mode），那么全局对象将无法使用默认绑定，因此 this 会绑定到 undefined：
function foo() {
"use strict";
console.log( this.a );
}
var a = 2;
foo(); // TypeError: this is undefined
```
当在函数内定义函数时，this会被绑定到全局对象上,一般是this赋值给that通过闭包来解决。
```js
//列一：
Myobject.double =function(){
				var that =this;
				var helper = function(){
					that.value = add(that.value,that.value)
				}
				helper();
			}
//列二：
function foo() {
console.log( this.a );
}
var obj = {
a: 2,
foo: foo
};
var a = "oops, global"; // a 是全局对象的属性
setTimeout( obj.foo, 100 ); // "oops, global"
//JavaScript 环境中内置的 setTimeout() 函数实现和下面的伪代码类似：
function setTimeout(fn,delay) {
// 等待 delay 毫秒
fn(); // <-- 调用位置！
}
```
bind方法，如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则：
bind 和 call/apply 的区别，一个函数被 call/apply 的时候，会直接调用，但是 bind 会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，新函数的参数将会和原函数的参数合并成为原函数的参数。

```js
function foo(something) {
console.log( this.a, something );
return this.a + something;
}
var obj = {
a:2
};
var bar = foo.bind( obj );
var b = bar( 3 ); // 2 3
console.log( b ); // 5
```
```js
function foo() {
console.log( this.a );
}
var a = 2;
var o = { a: 3, foo: foo };
var p = { a: 4 };
o.foo(); // 3
(p.foo = o.foo)(); // 2
//赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是 foo() 而不是
//p.foo() 或者 o.foo()。根据我们之前说过的，这里会应用默认绑定。
```

#### 闭包

有权访问另一个函数作用域中变量的函数就是闭包，闭包只能取得包含函数在任何变量的最后一个值。
闭包也能建立模块，让外界访问不到变量。

#### 闭包的作用

1. 使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)

2. 让函数外部可以操作(读写)到函数内部的数据(变量/函数)

  ##### 闭包的应用: 定义JS模块

   具有特定功能的js文件
  将所有的数据和功能都封装在一个函数内部(私有的)
  只向外暴露一个包信n个方法的对象或函数
  模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能
```js
// 自定义模块1
function coolModule() {
  //私有的数据
  var msg = 'atguigu'
  var names = ['I', 'Love', 'you']
  //私有的操作数据的函数
  function doSomething() {
    console.log(msg.toUpperCase())
  }
  function doOtherthing() {
    console.log(names.join(' '))
  }
  //向外暴露包含多个方法的对象
  return {
    doSomething: doSomething,
    doOtherthing: doOtherthing
  }
}
 //自定义模块2
(function (window) {
  //私有的数据
  var msg = 'atguigu'
  var names = ['I', 'Love', 'you']
  //操作数据的函数
  function a() {
    console.log(msg.toUpperCase())
  }
  function b() {
    console.log(names.join(' '))
  }
  window.coolModule2 =  {
    doSomething: a,
    doOtherthing: b
  }
})(window)\
```
##### 闭包的缺点

  函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长
  容易造成内存泄露

##### 解决方法

  能不用闭包就不用
  及时释放 = null // 释放