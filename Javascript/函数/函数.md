

#### 函数

函数实际上是对象，每个函数都是Function的实例。函数名仅仅存着指向函数的指针，所以一个函数可以有多个名字。所以javascript函数没有重载，后面的会覆盖前面的。

#### 函数的返回值

如果return后面没跟内容，或者没有写return ，返回undefined；

#### rguments.callee

是一个指针，指向拥有这个 arguments 对象的函数（即正在执行的函数），这样factorial赋值给新的函数，factorial被修改了，使用新的函数也不会出错。

```js
function factorial(num){ 
 if (num <=1) { 
 return 1; 
 } else { 
 return num * arguments.callee(num-1) 
 } 
} 
```

#### 闭包

有权访问另一个函数作用域中变量的函数就是闭包，闭包只能取得包含函数在任何变量的最后一个值。
闭包也能建立模块，让外界访问不到变量。

#### 闭包的作用

1. 使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)

2. 让函数外部可以操作(读写)到函数内部的数据(变量/函数)

  ##### 闭包的应用: 定义JS模块

   具有特定功能的js文件
  将所有的数据和功能都封装在一个函数内部(私有的)
  只向外暴露一个包信n个方法的对象或函数
  模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能
```js
// 自定义模块1
function coolModule() {
  //私有的数据
  var msg = 'atguigu'
  var names = ['I', 'Love', 'you']
  //私有的操作数据的函数
  function doSomething() {
    console.log(msg.toUpperCase())
  }
  function doOtherthing() {
    console.log(names.join(' '))
  }
  //向外暴露包含多个方法的对象
  return {
    doSomething: doSomething,
    doOtherthing: doOtherthing
  }
}
 //自定义模块2
(function (window) {
  //私有的数据
  var msg = 'atguigu'
  var names = ['I', 'Love', 'you']
  //操作数据的函数
  function a() {
    console.log(msg.toUpperCase())
  }
  function b() {
    console.log(names.join(' '))
  }
  window.coolModule2 =  {
    doSomething: a,
    doOtherthing: b
  }
})(window)\
```
##### 闭包的缺点

  函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长
  容易造成内存泄露

##### 解决方法

  能不用闭包就不用
  及时释放 = null // 释放